# Plan de Acción: Portal de Clientes (Versión Corregida)

Tras la revisión, se confirma que las entidades `Cliente` y `Usuario` deben permanecer completamente separadas. Los `Usuarios` son el personal interno y los `Clientes` son entidades externas.

La nueva estrategia consiste en añadir un sistema de autenticación propio y exclusivo para la entidad `Cliente`.

---

### Fase 1: Habilitar Autenticación en la Entidad `Cliente`

El objetivo es modificar la tabla `Clientes` en la base de datos para que pueda almacenar credenciales de acceso.

1.  **Modificar la Entidad `Cliente`:**
    *   **Acción:** Editar el archivo `FacturasSRI.Domain/Entities/Cliente.cs`.
    *   **Detalles:**
        *   Añadir un campo para la contraseña: `public string PasswordHash { get; set; } = string.Empty;`.
        *   Añadir campos para la recuperación de contraseña (recomendado): `public string? PasswordResetToken { get; set; }` y `public DateTime? PasswordResetTokenExpiry { get; set; }`.

2.  **Asegurar Unicidad del Email:**
    *   **Acción:** Configurar un índice único para el campo `Email` en la entidad `Cliente`.
    *   **Detalle:** Esto se hace en `FacturasSRI.Infrastructure/Persistence/Configurations/ClienteConfiguration.cs` (si existe) o directamente en el `DbContext`. Se debe añadir `.HasIndex(c => c.Email).IsUnique()`. El email será el nombre de usuario para el inicio de sesión.

3.  **Actualizar la Base de Datos:**
    *   **Acción:** Crear y aplicar una nueva migración de Entity Framework.
    *   **Detalle:** Ejecutar `dotnet ef migrations add AddAuthToCliente` para generar el script que aplicará los nuevos campos y el índice único a la tabla `Clientes`. Luego, aplicar la migración.

---

### Fase 2: Implementar Lógica de Autenticación del Cliente

Esta fase crea la funcionalidad de registro e inicio de sesión, operando exclusivamente sobre la entidad `Cliente`.

1.  **Crear DTOs para el Portal:**
    *   **Acción:** Crear nuevos DTOs en `FacturasSRI.Application/Dtos`.
    *   **Detalles:**
        *   `ClienteRegistroDto`: Contendrá los campos para un nuevo cliente (`RazonSocial`, `NumeroIdentificacion`, `Email`, etc.) además de un campo `string Password`.
        *   `ClienteLoginDto`: Contendrá solo `string Email` y `string Password`.

2.  **Extender el Servicio de Clientes (`ICustomerService`):**
    *   **Acción:** Añadir nuevos métodos a `ICustomerService` y su implementación en `CustomerService.cs`. **No se usará `IUserService`**.
    *   **Detalles:**
        *   `Task<ClienteDto> RegistrarNuevoClienteAsync(ClienteRegistroDto dto)`:
            *   Validará que el email y el número de identificación no existan.
            *   Creará una nueva entidad `Cliente`. El campo `UsuarioIdCreador` puede ser nulo.
            *   Hasheará la contraseña del DTO usando `BCrypt.Net.BCrypt.HashPassword` y la guardará en el campo `PasswordHash` del nuevo cliente.
            *   Guardará el cliente en la base de datos.
        *   `Task<ClienteDto?> AutenticarClienteAsync(ClienteLoginDto dto)`:
            *   Buscará un cliente por su `Email`.
            *   Si lo encuentra, usará `BCrypt.Net.BCrypt.Verify` para comparar la contraseña del DTO con el `PasswordHash` almacenado.
            *   Si la contraseña es correcta, devolverá el `ClienteDto`; de lo contrario, `null`.

3.  **Configurar un Nuevo Esquema de Autenticación:**
    *   **Acción:** En `Program.cs`, registrar un nuevo esquema de autenticación basado en cookies específicamente para los clientes (ej. `"CustomerAuth"`).
    *   **Detalle:** Esto aislará las sesiones de los clientes de las sesiones del personal (`Usuarios`). Se definirá también una política de autorización, como por ejemplo `"IsCustomer"`.

4.  **Crear Controlador de Autenticación del Portal:**
    *   **Acción:** Crear `PortalAuthController.cs` en `FacturasSRI.Web/Controllers`.
    *   **Detalles:**
        *   `[HttpPost("register")]`: Endpoint público que llama a `RegistrarNuevoClienteAsync`.
        *   `[HttpPost("login")]`: Endpoint público que llama a `AutenticarClienteAsync`. Si tiene éxito, genera una `ClaimsPrincipal` para el cliente, le asigna un Claim de rol/tipo "Cliente" y emite la cookie de autenticación usando el esquema `"CustomerAuth"`.
        *   `[HttpPost("logout")]`: Endpoint que cierra la sesión del cliente.

---

### Fase 3: Creación de la Interfaz de Usuario en Blazor (Andamiaje)

Esta fase se centra en construir el andamiaje visual del portal utilizando componentes de Blazor, sin implementar aún la lógica completa.

1.  **Crear Páginas de Login y Registro:**
    *   **Acción:** Crear los componentes de página `Login.razor` y `Registro.razor` en una nueva carpeta dentro del proyecto web (ej. `FacturasSRI.Web/Components/Pages/PortalAuth`).
    *   **Detalle:** Serán componentes enrutables con formularios que apuntarán a los nuevos endpoints del `PortalAuthController`.

2.  **Layout y Componentes del Portal:**
    *   **Acción:** Crear un componente de layout `ClienteLayout.razor`.
    *   **Detalle:** Este layout contendrá la estructura principal para las vistas del cliente, incluyendo el menú de navegación. La página `Dashboard.razor` usará este layout.

3.  **Proteger Rutas del Portal:**
    *   **Acción:** Envolver el contenido de las páginas del cliente (como `Dashboard.razor`) con el componente `<AuthorizeView>`.
    *   **Detalle:** Se configurará el componente para que solo muestre el contenido a los usuarios autenticados que cumplan con la nueva política: `<AuthorizeView Policy="IsCustomer">`.

4.  **Menú de Navegación Dinámico:**
    *   **Acción:** Modificar el menú de navegación principal (probablemente `NavMenu.razor`).
    *   **Detalle:** Se usará el componente `<AuthorizeView>` para mostrar condicionalmente los enlaces del portal del cliente solo si el usuario está autenticado con la política "IsCustomer", y ocultar los enlaces de administrador/vendedor.

Este plan actualizado es más seguro, robusto y respeta la arquitectura de la aplicación.
